include "list.pixi"

MAX_GENS = 256

fn embe() {
    $this = new()
    $this.gens = new(MAX_GENS, INT16)
    $this.index = 0;

    $this.add = { // $this, $node
        $this = $1
        $node = $2

        $node.ready = 0
        $node.in_count = 0

        $node.clients = -1

        if $node.is_gen {
            $this.gens[$this.index] = $node
            $this.index + 1
        }

        ret ($this)
    }

    $this.join = { // $this, $node1 <- $node2
        $this = $1
        $node1 = $2
        $node2 = $3

        $node2.clients = _($node1, $node2.clients)
        $node1.ready - 1
        $node1.in_count + 1
    }

    $this.process = { // $this, $frames
        $this = $1
        $frames = $2
        if $this.shut > 0 {
            ret
        }
        $i = 0 while ($i < $this.index) {
            $node = $this.gens[$i]
            $this.process_node($this, $node, $frames)
            $i + 1
        }
    }

    $this.process_node = {
        $this = $1
        $node = $2
        $frames = $3

        if $node.ready < 0 {
            ret
        }
    
        $sig = $node.gen($node, $frames)

        if $sig == 0 {
            ret
        }

        if $node.buf {
            remove($node.buf)
            $node.buf = 0
        }

        $clients = $node.clients
        while $clients.Head > 0 {
            $client = $clients.Head
            $clients = $clients.Tail

            if $client.ready < 0 {
                if $client.ready == -$client.in_count {
                    if $client.buf == 0 {
                        $client.buf = new($frames, 1, FLOAT32)
                        clean($client.buf)
                    }
                    copy($client.buf, $sig)
                } else {
                    op_cc(OP_ADD, $client.buf, $sig, $frames)
                }
                $client.ready + 1
            }

            if $client.ready == 0 {
                $this.process_node($this, $client, $frames)
                $client.ready = -$client.in_count
            }
        }
        remove($sig)
    }

    ret ($this)
}

fn mix($amp) {
    $this = new()
    $this.Amp = $amp

    $this.gen = {
        $this = $1
        $frames = $2

        $sig = new($frames, 1, FLOAT32)
        copy($sig, $this.buf)
        op_cn(OP_MUL, $sig, $this.Amp)

        ret ($sig)
    }

    ret ($this)
}

fn out() {
    $this = new()

    $this.gen = {ret (0)}

    ret ($this)
}

Embe = embe()

fn run($node) {
    fn audio_callback(
        $stream,
        $node,
        $channels,
        $frames,
        $output_time_in_system_ticks,
        $in_channels,
        $latency_in_frames
    ) {
        Embe.process(Embe, $frames, $in_channels)
        copy($channels[0], $node.buf)
        ret (1)
    }

    enable_audio_input(1)
    set_audio_callback(audio_callback, $node, 0, FLOAT32, 1, AUDIO_FLAG_INTERP2)
    start_timer(0)
}

fn shut() {
    set_audio_callback(-1)
    enable_audio_input(0)
}

fn a($node) {
    Embe.add(Embe, $node)
    ret ($node)
}

fn j($node1, $node2) {
    Embe.join(Embe, $node1, $node2)
}
