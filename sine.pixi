SRATE = 44100
MAXINT = 127
MININT = -128


fn _($el, $list) {
    $l = new()
    $l.Tail = $list
    $l.Head = $el
    ret ($l)
}

fn out($sig) {
    fn audio_callback(
        $stream,
        $sig,
        $channels,
        $frames,
        $output_time_in_system_ticks,
        $in_channels,
        $latency_in_frames )
    {
        $sig.gen($sig, $channels, $frames)
        copy(buf, $channels[0])
        ret( 1 )
    }

    set_audio_callback( audio_callback, $sig, SRATE, INT8, 1, AUDIO_FLAG_INTERP2)
}

fn osc_sin($freq, $amp) {

    $this = new()

    $this._phase = 0
    $this._freq = $freq
    $this._amp = $amp

    $this.gen = { // $this, $channels, $frames
        $this = $1
        $channels = $2
        $frames = $3

        $p = 2 * M_PI * $this._phase / SRATE
        $d = 2 * M_PI * $this._freq / SRATE

        generator(OP_SIN8, $channels[0], $p, $this._amp * MAXINT, $d, 0)

        $this._phase + $this._freq * $frames

        if $this._phase > SRATE {
            $this._phase % SRATE
        } 
    }

    ret ($this)
}

fn osc_sqr($freq, $amp) {

    $this = new()

    $this._phase = 0
    $this._freq = $freq
    $this._amp = $amp

    $this.gen = { // $this, $channels, $frames
        $this = $1
        $channels = $2
        $frames = $3

        $p = 2 * M_PI * $this._phase / SRATE
        $d = 2 * M_PI * $this._freq / SRATE

        generator(OP_SIN8, $channels[0], $p, MAXINT, $d, 0)
        op_cn(OP_GREATER, $channels[0], 0)
        op_cn(OP_MUL, $channels[0], 2 * MAXINT * $this._amp)
        op_cn(OP_ADD, $channels[0], -MAXINT * $this._amp)

        $this._phase + $this._freq * $frames

        if $this._phase > SRATE {
            $this._phase % SRATE
        } 
    }

    ret ($this)
}

fn osc_saw($freq, $amp) {

    $this = new()

    $this._phase = 0
    $this._freq = $freq
    $this._amp = $amp

    $this.gen = { // $this, $channels, $frames
        $this = $1
        $channels = $2
        $frames = $3

        $p = 2 * M_PI * $this._phase / SRATE
        $d = 2 * M_PI * $this._freq / SRATE

        generator(OP_SIN8, $channels[0], $p, MAXINT, $d, 0)

        op_cn(OP_EQUAL, $channels[0], 0)
        op_cn(OP_SUB, $channels[0], 1)
        op_cn(OP_H_INTEGRAL, $channels[0])

        op_cn(OP_MUL, $channels[0], 2 * MAXINT)
        op_cn(OP_ADD, $channels[0], MAXINT)


        $this._phase + $this._freq * $frames

        if $this._phase > SRATE {
            $this._phase % SRATE
        } 
    }

    ret ($this)
}


fn filter($freq, $q, $type) {
    $this = new()

    $this._freq = $freq
    $this._q = $q
    $this._filter = new_filter()

    $omega = 2 * M_PI * $this._freq / SRATE
    $tsin = sin( $omega )
    $tcos = cos( $omega )
    $alpha = $tsin / ( 2 * $this._q )

    if $type == 0 {
        //Low-pass:
        $b0 = ( 1 - $tcos ) / 2
        $b1 = 1 - $tcos
        $b2 = ( 1 - $tcos ) / 2
        $a0 = 1 + $alpha
        $a1 = -2 * $tcos
        $a2 = 1 - $alpha
    }

    if $type == 1 {
        //High-pass
        $b0 = ( 1 + $tcos ) / 2
        $b1 = -( 1 + $tcos )
        $b2 = ( 1 + $tcos ) / 2
        $a0 = 1 + $alpha
        $a1 = -2 * $tcos
        $a2 = 1 - $alpha
    }

    if $type == 2 {
        //Band-pass:
        $b0 = $alpha
            $b1 = 0
        $b2 = -$alpha
        $a0 = 1 + $alpha
        $a1 = -2 * $tcos
        $a2 = 1 - $alpha
    }

    if $type == 3 {
        //Notch:
        $b0 = 1
        $b1 = -2 * $tcos
        $b2 = 1
        $a0 = 1 + $alpha
        $a1 = -2 * $tcos
        $a2 = 1 - $alpha
    }

    if $type == 4 {
        //All-pass:
        $b0 = 1 - $alpha
        $b1 = -2 * $tcos
        $b2 = 1 + $alpha
        $a0 = 1 + $alpha
        $a1 = -2 * $tcos
        $a2 = 1 - $alpha
    }

    $ff = new(3, 1, INT8) //feedforward filter coefficients
    $fb = new(2, 1, INT8) //feedback filter coefficients
    $ff[0] = $b0 / $a0
    $ff[1] = $b1 / $a0
    $ff[2] = $b2 / $a0
    $fb[0] = -$a1 / $a0
    $fb[1] = -$a2 / $a0

    printf("%d\n", $ff[0])
    printf("%d\n", $ff[1])
    printf("%d\n", $ff[2])



    init_filter($this._filter, $ff, $fb)

    $this.join = { // $this, $sig
        $this = $1
        $sig = $2

        $this._signal = $sig
    }

    $this.gen = { // $this, $channels, $frames
        $this = $1
        $channels = $2
        $frames = $3

        $ch = new(1, 1)
        $ch[0] = new($frames, 1, INT8)

        $this._signal.gen($this._signal, $ch, $frames)
        
	    apply_filter($this._filter, $channels[0], $ch[0], 0, 0, $frames)
    }

    ret ($this)
}

/* TODO:
    - Именовать узлы для доступа
*/
fn mix() {
    $this = new()
    $this._signals = 0
    $this._counter = 0

    $this.join = { // $this, $sig
        $this = $1
        $sig = $2
        $this._counter + 1
        $this._signals = _($sig, $this._signals)
    }

    $this.gen = { // $this, $channels, $frames
        $this = $1
        $channels = $2
        $frames = $3

        clean($channels[0])

        $ch = new(1, 1)
        $ch[0] = new($frames, 1, INT8)

        $signals = $this._signals
        $i = 0 while $i < $this._counter {
            $i + 1
            $sig = $signals.Head
            $signals = $signals.Tail

            $sig.gen($sig, $ch, $frames)
            
            op_cc(OP_SADD, $channels[0], $ch[0], $frames)
        }
    }

    ret ($this)
}

fn join($proc, $sig) {
    $proc.join($proc, $sig)
}

$o1 = osc_sqr(220, 0.3)
$o2 = osc_sin(224, 0.3)
$o3 = osc_saw(440, 0.3)
$mix = mix()

join($mix, $o1)
join($mix, $o2)
join($mix, $o3)

$flt = filter(330, 5, 0)
join($flt, $mix)
out($flt)

buf = new( 1024, 1, INT8 )
clean( buf )
while( 1 )
{
    clear()
    
    x = 0 while( x < 1024 ) {
    	dot( x - 512, buf[ x ] / 2, GREEN )
	    x + 1
    }
    
    while( get_event() ) { if EVT[ EVT_TYPE ] == EVT_QUIT { halt } }
    
    frame()
}



